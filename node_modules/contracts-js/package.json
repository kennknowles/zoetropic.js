{
  "name": "contracts-js",
  "description": "A contract library for JavaScript",
  "keywords": [
    "javascript",
    "contracts"
  ],
  "author": {
    "name": "Tim Disney"
  },
  "version": "0.3.4",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/disnet/contracts.js/master/LICENSE"
    }
  ],
  "engines": {
    "node": ">=0.8.0"
  },
  "main": "./lib/contracts.js",
  "directories": {
    "lib": "./lib"
  },
  "homepage": "http://disnetdev.com/contracts.js/",
  "repository": {
    "type": "git",
    "url": "git://github.com/disnet/contracts.js.git"
  },
  "readme": "Contracts.js\n============\n\nContracts.js is a contract library for JavaScript that allows you to specify invariants between parts of your code and have them checked at runtime for violations. \n\nIt is used in the CoffeeScript dialect [contracts.coffee](http://disnetdev.com/contracts.coffee/) but can also be used directly in normal JavaScript programs if you don't want to or can't use CoffeeScript.\n\nThis library is possible because of and requires [Proxies](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Proxy) which is a new feature of JavaScript that is currently only implemented in Firefox 4+ and chrome/V8 with the experimental javascript flag enabled \n(in about:flags or use the `--harmony` flag on the command line). \n\nUse\n===\n\nTo use include these files:\n\n  * src/stacktrace.js\n  * lib/contracts.js\n\nThis adds a `Contracts` object to the global scope that has two properties `Contracts.contracts` (which contains some prebuilt contracts to use) and `Contracts.combinators` (which contains utility functions to build new contracts).\n\nWe can now wrap a function in a contract like so:\n\n    var C = contracts,\n    \tid = C.guard(\n              C.fun(C.Num, C.Num),\n              function(x) { return x; });\n\n    id(\"foo\"); // contract violation!\n\nIf you would like to load all of the combinators into the global scope, just run `contracts.autoload()`.\n\nMore documentation and rational can be found at the sister project [contracts.coffee](http://disnetdev.com/contracts.coffee/).\n\nContracts.guard\n===========================\n\nGuards a value with a contract\n\n\tContracts.guard :: (Contract, Any, Str?, Str?) -> { use: () -> Any }\n    Contracts.guard(contract, value [, server[, client]])\n\n  * _contract_ the contract to apply to the value\n  * _value_ value to be wrapped in a contract\n  * _server_ optional name of the server \"module\"\n  * _client_ optional name of the client \"module\"\n\n\n\nContracts.check\n===========================\n\nCreates a contract that checks first-order values (i.e. not functions or objects).\n\n\tContracts.check :: ((Any) -> Bool, Str) -> Contract\n\tContracts.check(predicate, name)\n\n  * _predicate_ function that takes a value and return true if the contract should pass or false otherwise\n  * _name_ name of the contract. Displayed in contract violation messages.\n\nThis is used to build contracts that get applied to values via the `guard` function. The `guard` function handles calling the predicate supplied to `check` at the appropriate time.\n\nAn example of a contract to check for numbers:\n\t\n\tContracts.check(function(x) { \n\t\treturn typeof(x) === 'number'; \n\t}, 'Number')\n\nContracts.fun\n=========================\n\n\tContracts.fun :: (Contract or [...Contract], \n\t\t\t\t\t\t\t\t \t((Any) -> Contract) or Contract,\n\t\t\t\t\t\t\t\t \t{\n\t\t\t\t\t\t\t\t \t\tcallOnly: Bool\n\t\t\t\t\t\t\t\t \t\tnewOnly: Bool\n\t\t\t\t\t\t\t\t \t\tpre: (Any) -> Bool\n\t\t\t\t\t\t\t\t \t\tpost: (Any) -> Bool\n\t\t\t\t\t\t\t\t \t\tthis: {...}\n\t\t\t\t\t\t\t\t \t}) -> Contract\n\tContracts.fun(domain, range, options)\n\n  * _domain_ Either a single contract or an array of contracts for each argument to the function\n  * _range_ Either a single contract for the function's result or a function that returns a contract.\n  * _options_ An options object:\n\t* _callOnly_ Signal a contract violation if `new` is used with the function\n\t* _newOnly_ Signal a contract violation if `new` is _not_ used with the function\n\t* _pre_ A predicate to run _before_ the function is run\n\t* _post_ A predicate to run _after_ the function is run\n\t* _this_ An object contract to guard the `this` object\n\nDependent function contracts (where the result depends on the argument values) are handled by using a function as the `range`. When the function returns its argument values are first passed to the `range` function which should return a contract. This contract is then used to check the original function's result.\n\nAs a contrived example:\n\n\tContracts.fun(Str, function(x) { \n\t\tif(x === 42) {\n\t\t\treturn Contracts.Num;\n\t\t} else {\n\t\t\treturn Contracts.Str;\n\t\t}\n\t})\n\nIf the function contracted is called with `42` then its result must be a `Num` otherwise it must be a `Str`.\n\nNote that arguments are potentially mutable (they might be one value at the beginning of the function and different when the function returns) so keep that in mind when using dependent contracts.\n\nContracts.object\n============================\n\n\n\tContracts.object :: ({ ... }, \n\t\t\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\t\t\textensible: Bool\n\t\t\t\t\t\t\t\t\t\t\tsealed: Bool\n\t\t\t\t\t\t\t\t\t\t\tfrozen: Bool\n\t\t\t\t\t\t\t\t\t\t\tinvariant: (Any) -> Bool\n\t\t\t\t\t\t\t\t\t\t}) -> Contract\n\tContracts.object(object, options)\n\n  * _object_ An object with properties mapping to contracts that should be present in the contracted object\n  * _options_ An objects object:\n    * _extensible_ Object should be extensible\n    * _sealed_ Object should be sealed\n    * _frozen_ Object should be frozen\n    * _invariant_ Predicate to run each time the contracted object changes\n\nObject contracts are built with an object that maps properties to objects. Example:\n\n\tContracts.object({\n\t\tfoo: Str,\n\t\tbar: Num\n\t})\n\nIn this case the contracted object must have both the `foo` and `bar` properties (if missing, a contract violation is thrown at contract application time) and these properties must abide by their respective contracts (which are checked each time the property is changed).\n\nObject invariants can be checked with the invariant option. Whenever any property is changed the invariant function is called with a reference to the object. If the invariant returns false a contract violation is thrown.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/disnet/contracts.js/issues"
  },
  "_id": "contracts-js@0.3.4",
  "_from": "contracts-js@>=0.3.3"
}
